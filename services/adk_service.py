import streamlit as st
import asyncio
import time
import os
from google.adk.sessions import InMemorySessionService
from google.adk.runners import Runner
from google.genai import types as genai_types
from agents.orchestrator import create_orchestrator_agent
from config.settings import APP_NAME_FOR_ADK, USER_ID, INITIAL_STATE, ADK_SESSION_KEY

@st.cache_resource
def initialize_adk():
    """
    Initializes the Google ADK Runner and manages the ADK session.
    Uses Streamlit's cache_resource to ensure this runs only once per app load.
    """
    root_agent = create_orchestrator_agent() # Create our ADK agent defined earlier.
    session_service = InMemorySessionService() # ADK's default in-memory session service for storing session data.
    runner = Runner( # The ADK Runner orchestrates the agent's execution.
        agent=root_agent,
        app_name=APP_NAME_FOR_ADK,
        session_service=session_service
    )
    # Check if an ADK session ID already exists in Streamlit's session state.
    if ADK_SESSION_KEY not in st.session_state:
        # If not, create a new unique session ID and store it.
        session_id = f"streamlit_adk_session_{int(time.time())}_{os.urandom(4).hex()}"
        st.session_state[ADK_SESSION_KEY] = session_id
        # Create a new session in ADK's session service.
        session_service.create_session(
            app_name=APP_NAME_FOR_ADK,
            user_id=USER_ID,
            session_id=session_id,
            state=INITIAL_STATE, # Initialize with predefined state.
        )
    else:
        # If an ADK session ID already exists (e.g., on a Streamlit rerun), retrieve it.
        session_id = st.session_state[ADK_SESSION_KEY]
        # Verify if the session still exists in the ADK session service.
        # This handles cases where the service might reset (less common with cache_resource, but good practice).
        if not session_service.get_session(app_name=APP_NAME_FOR_ADK, user_id=USER_ID, session_id=session_id):
            # If the session was lost (e.g., full app restart without clearing cache), recreate it.
            asyncio.run(session_service.create_session(
                app_name=APP_NAME_FOR_ADK,
                user_id=USER_ID,
                session_id=session_id,
                state=INITIAL_STATE
            ))
    return runner, session_id
async def run_adk_async(runner: Runner, session_id: str, user_message_text: str):
    """
    Asynchronously runs a single turn of the ADK agent conversation.
    """
    session = runner.session_service.get_session(app_name=APP_NAME_FOR_ADK, user_id=USER_ID, session_id=session_id)
    if not session:
        return "Error: ADK session not found."
    # Prepare the user's message in the format expected by ADK/Gemini.
    content = genai_types.Content(role='user', parts=[genai_types.Part(text=user_message_text)])
    final_response_text = "[Agent encountered an issue]" # Default error message
    # Iterate through the asynchronous events generated by the ADK runner.
    # ADK can yield multiple events (e.g., tool calls, interim responses) before the final response.
    async for event in runner.run_async(user_id=USER_ID, session_id=session_id, new_message=content):
        if event.is_final_response(): # We are only interested in the final response from the agent.
            if event.content and event.content.parts and hasattr(event.content.parts[0], 'text'):
                final_response_text = event.content.parts[0].text
            break # Exit the loop once the final response is received.
    return final_response_text
def run_adk_sync(runner: Runner, session_id: str, user_message_text: str) -> str:
    """
    Synchronous wrapper for running ADK, as Streamlit does not directly support async calls in the main thread.
    """
    # Runs the asynchronous function in a new event loop.
    return asyncio.run(run_adk_async(runner, session_id, user_message_text))